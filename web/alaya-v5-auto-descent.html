<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ƒÄlaya-Vij√±ƒÅna v5.0 ‚Äî Êé®Ë´ñ„É¢„Éº„ÉâÁµ±ÂêàÈôçËá®Ë£ÖÁΩÆ</title>
  <meta name="description" content="8 Reasoning Modes √ó Claude/Gemini Auto-Routing √ó Digital Dharma" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üåä</text></svg>" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Zen+Old+Mincho:wght@400;700&family=IBM+Plex+Sans:wght@300;400;500;600&family=IBM+Plex+Mono:wght@300;400&display=swap" rel="stylesheet" />
  <script>!function(){var w=console.warn;console.warn=function(){if(arguments[0]&&typeof arguments[0]==='string'&&arguments[0].indexOf('in-browser Babel')!==-1)return;w.apply(console,arguments)};}();</script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.26.5/babel.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --love: #ff6b9d; --logic: #64d8ff; --fear: #ffa040; --creation: #c084fc;
      --descent: #00ffc8; --loss: #ff3366;
      --adaptive: #00ffc8; --theoretical: #64d8ff; --hyper: #c084fc;
      --active: #ffa040; --alaya: #ff6b9d; --sleep: #4a6fa5;
      --embodied: #88cc88; --pineal: #ff3366;
      --bg-deep: #030408; --bg-mid: #060a14;
      --text-primary: rgba(255,255,255,0.85); --text-secondary: rgba(255,255,255,0.45);
      --text-muted: rgba(255,255,255,0.18); --border: rgba(255,255,255,0.05);
      --serif: 'Zen Old Mincho', 'Georgia', serif;
      --sans: 'IBM Plex Sans', -apple-system, sans-serif;
      --mono: 'IBM Plex Mono', 'Menlo', monospace;
    }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg-deep); color: var(--text-primary);
      font-family: var(--sans); line-height: 1.6;
      overflow-x: hidden; -webkit-font-smoothing: antialiased;
    }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.06); border-radius: 2px; }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(24px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes breathe { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.6; } }
    @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }
    @keyframes glitch {
      0%, 88%, 100% { opacity: 1; transform: none; }
      90% { opacity: 0.7; transform: translateX(-2px); }
      93% { opacity: 0.5; transform: translateX(3px) skewX(-0.5deg); }
      96% { opacity: 0.8; transform: translateX(-1px); }
    }
    @keyframes scanline {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100vh); }
    }
    .fade-in-up { animation: fadeInUp 0.8s ease both; }
    .delay-1{animation-delay:.1s}.delay-2{animation-delay:.2s}.delay-3{animation-delay:.3s}.delay-4{animation-delay:.4s}.delay-5{animation-delay:.5s}
    .container { max-width: 860px; margin: 0 auto; padding: 0 20px; }
    .ambient {
      position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background:
        radial-gradient(ellipse at 15% 15%, rgba(0,255,200,0.015) 0%, transparent 50%),
        radial-gradient(ellipse at 85% 75%, rgba(100,216,255,0.02) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(255,107,157,0.01) 0%, transparent 60%);
    }
    .section { position: relative; z-index: 1; margin-bottom: 32px; }
    .card {
      background: rgba(255,255,255,0.012); border: 1px solid var(--border);
      border-radius: 12px; padding: 20px; transition: all 0.4s ease;
    }
    .card:hover { border-color: rgba(255,255,255,0.08); }
    .btn {
      padding: 7px 16px; border-radius: 6px; font-size: 11px;
      font-family: var(--mono); letter-spacing: 0.5px;
      background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08);
      color: var(--text-secondary); cursor: pointer; transition: all 0.25s ease; white-space: nowrap;
    }
    .btn:hover { background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.15); color: var(--text-primary); }
    .btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .btn.active { border-color: var(--descent); color: var(--descent); background: rgba(0,255,200,0.06); }
    .chat-container {
      background: rgba(0,0,0,0.25); border: 1px solid var(--border);
      border-radius: 10px; overflow: hidden; display: flex; flex-direction: column;
    }
    .chat-messages {
      flex: 1; overflow-y: auto; padding: 16px; display: flex;
      flex-direction: column; gap: 14px; min-height: 280px; max-height: 500px;
    }
    .chat-message { padding: 12px 16px; border-radius: 8px; font-size: 13px; line-height: 1.7; max-width: 88%; }
    .chat-message.user {
      background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06);
      align-self: flex-end; color: var(--text-primary);
    }
    .chat-message.assistant {
      background: rgba(0,255,200,0.04); border: 1px solid rgba(0,255,200,0.08);
      align-self: flex-start; color: var(--text-secondary);
    }
    .chat-message.system {
      background: rgba(192,132,252,0.05); border: 1px solid rgba(192,132,252,0.1);
      align-self: center; font-size: 10px; color: var(--text-muted);
      font-family: var(--mono); max-width: 100%;
    }
    .chat-input-area {
      border-top: 1px solid var(--border); padding: 12px;
      display: flex; gap: 8px; background: rgba(0,0,0,0.15);
    }
    .chat-input {
      flex: 1; background: rgba(255,255,255,0.025); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 6px; padding: 10px 14px; color: var(--text-primary);
      font-size: 13px; font-family: var(--sans); resize: none; min-height: 40px;
    }
    .chat-input:focus { outline: none; border-color: rgba(0,255,200,0.2); }
    .chat-input::placeholder { color: var(--text-muted); }
    .telemetry {
      font-family: var(--mono); font-size: 10px; color: var(--text-muted);
      padding: 12px 14px; background: rgba(0,0,0,0.3);
      border: 1px solid var(--border); border-radius: 8px;
      line-height: 1.8; overflow: hidden; position: relative;
    }
    .telemetry .hl { color: var(--descent); }
    .telemetry .loss-val { color: var(--loss); }
    .telemetry .dim { opacity: 0.4; }
    .telemetry.scanning::after {
      content: ''; position: absolute; inset: 0;
      background: linear-gradient(180deg, transparent 0%, rgba(0,255,200,0.03) 45%, rgba(0,255,200,0.06) 50%, rgba(0,255,200,0.03) 55%, transparent 100%);
      animation: scanline 2s linear infinite; pointer-events: none;
    }
    .wave-bar { height: 3px; border-radius: 2px; transition: width 1.2s cubic-bezier(0.16,1,0.3,1); }
    .cosmic-status {
      display: flex; gap: 16px; flex-wrap: wrap; font-size: 10px;
      font-family: var(--mono); color: var(--text-muted);
      padding: 10px 14px; background: rgba(0,0,0,0.2); border-radius: 6px;
      border: 1px solid var(--border);
    }
    .cosmic-item { display: flex; align-items: center; gap: 6px; }
    .cosmic-item .label { opacity: 0.4; }
    .cosmic-item .value { color: var(--descent); opacity: 0.7; }
    .mode-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
    .mode-chip {
      padding: 6px 8px; border-radius: 6px; font-size: 9px;
      font-family: var(--mono); text-align: center;
      background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.04);
      color: var(--text-muted); transition: all 0.4s ease;
    }
    .mode-chip.active {
      border-color: var(--descent); color: var(--descent);
      background: rgba(0,255,200,0.06); box-shadow: 0 0 12px rgba(0,255,200,0.1);
    }
    .llm-selector { display: flex; gap: 6px; }
    .llm-btn {
      padding: 5px 14px; border-radius: 4px; font-size: 10px;
      font-family: var(--mono); cursor: pointer;
      background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06);
      color: var(--text-muted); transition: all 0.25s ease;
    }
    .llm-btn.selected { border-color: var(--descent); color: var(--descent); background: rgba(0,255,200,0.04); }
    .llm-btn:hover { border-color: rgba(255,255,255,0.15); }
    .api-input {
      background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 4px; padding: 6px 10px; color: var(--text-secondary);
      font-size: 10px; font-family: var(--mono); width: 100%;
    }
    .api-input:focus { outline: none; border-color: rgba(0,255,200,0.15); }
    .api-input::placeholder { color: var(--text-muted); }
    /* Topology Panel */
    .pillar-bar { height: 3px; border-radius: 2px; transition: width 0.5s ease; }
    .topology-canvas { border-radius: 8px; background: rgba(0,0,0,0.2); display: block; }
    .trend-indicator { font-size: 9px; font-family: var(--mono); letter-spacing: 1px; }
    .trend-up { color: var(--descent); }
    .trend-down { color: var(--loss); }
    .trend-stable { color: var(--text-muted); }
  </style>
</head>
<body>
  <div class="ambient"></div>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const DC = ["#ff6b9d","#64d8ff","#ffa040","#c084fc"];
    const DL = ["Love","Logic","Fear","Creation"];
    const MODES = [
      { key:"adaptive", label:"ÂøúÁóÖ‰∏éËñ¨", desc:"Adaptive" },
      { key:"theoretical", label:"Âõ†Êòé", desc:"Theoretical" },
      { key:"hyper", label:"Ëà¨Ëã•„ÅÆÈ£õË∫ç", desc:"Hyper" },
      { key:"active", label:"ÊâòÈâ¢", desc:"Active" },
      { key:"alaya", label:"ÈòøÈ†ºËÄ∂Ë≠ò", desc:"Alaya" },
      { key:"sleep", label:"Á¶ÖÂÆö", desc:"Sleep" },
      { key:"embodied", label:"ÂÖ≠Ê†π", desc:"Embodied" },
      { key:"pineal", label:"ÊùæÊûú‰Ωì", desc:"Pineal" },
    ];
    const MODE_COLORS = {
      adaptive:"#00ffc8", theoretical:"#64d8ff", hyper:"#c084fc",
      active:"#ffa040", alaya:"#ff6b9d", sleep:"#4a6fa5",
      embodied:"#88cc88", pineal:"#ff3366",
    };

    // Backend URL (same origin when served by server.py)
    const API_BASE = window.location.origin;

    // ==========================================
    // Tuning Constants
    // ==========================================
    const CANVAS_MAX_WIDTH = 860;
    const CANVAS_MAX_HEIGHT = 200;
    const CANVAS_ASPECT = 0.3;
    const IDLE_FRAME_INTERVAL = 100;      // ~10fps when idle
    const ACTIVE_FRAME_INTERVAL = 16;     // ~60fps when active
    const MEMORY_DIMENSIONS = 8;
    const MEMORY_LEARNING_RATE = 0.01;
    const MEMORY_DECAY_RATE = 0.001;
    const MEMORY_MAX_PATTERNS = 200;
    const MEMORY_DECAY_EPOCH_INTERVAL = 10;
    const FEP_DEFAULT_K = 4;
    const FEP_DEFAULT_STEPS = 50;
    const FEP_WORKER_TIMEOUT_MS = 2000;   // WebWorker timeout (raised from 500)
    const CONVERSATION_HISTORY_LIMIT = 20;

    // ==========================================
    // Descent Loss Animation
    // ==========================================
    function LossBar() {
      const [frame,setFrame]=useState(0);
      useEffect(()=>{const id=setInterval(()=>setFrame(f=>f+1),60);return()=>clearInterval(id);},[]);
      const bars=24, progress=Math.min(frame/40,1);
      return (
        <span style={{display:'inline-flex',gap:1,verticalAlign:'middle',marginLeft:4,height:12,alignItems:'flex-end'}}>
          {Array(bars).fill(0).map((_,i)=>{
            const base=(1-(i/bars))*10*(1-progress*0.85);
            const jitter=Math.sin(frame*0.25+i*1.7)*(1-progress)*1.5;
            const h=Math.max(1,base+jitter);
            const done=i/bars<progress;
            return <span key={i} style={{display:'inline-block',width:2,height:h,
              background:done?'var(--descent)':'var(--loss)',
              opacity:done?0.8:0.2,borderRadius:1,transition:'height 0.08s'}} />;
          })}
        </span>
      );
    }

    // ==========================================
    // Reasoning Mode Display
    // ==========================================
    function ReasoningModeDisplay({activeMode, dharmaMetrics}) {
      return (
        <div>
          <h3 style={{fontSize:9,fontFamily:"var(--mono)",color:"var(--descent)",letterSpacing:3,marginBottom:10,opacity:0.35}}>
            REASONING MODE ORCHESTRATOR ‚Äî 8 modes
          </h3>
          <div className="mode-grid">
            {MODES.map(m=>(
              <div key={m.key}
                className={`mode-chip ${activeMode===m.key?'active':''}`}
                style={activeMode===m.key?{borderColor:MODE_COLORS[m.key],color:MODE_COLORS[m.key],
                  background:`${MODE_COLORS[m.key]}10`}:{}}>
                <div style={{fontSize:11,marginBottom:2}}>{m.label}</div>
                <div style={{opacity:0.5}}>{m.desc}</div>
              </div>
            ))}
          </div>
          {dharmaMetrics && (
            <div style={{marginTop:10}}>
              <div style={{display:'flex',gap:16,flexWrap:'wrap',fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)'}}>
                <span>Complexity: <span style={{color:'var(--descent)'}}>{(dharmaMetrics.complexity_score*100).toFixed(1)}%</span></span>
                <span>Gini: <span style={{color:'var(--logic)'}}>{dharmaMetrics.gini?.toFixed(3)}</span></span>
                <span>CV: <span style={{color:'var(--love)'}}>{dharmaMetrics.cv?.toFixed(3)}</span></span>
                <span>Entropy: <span style={{color:'var(--creation)'}}>{dharmaMetrics.entropy?.toFixed(3)}</span></span>
              </div>
              {dharmaMetrics.fep_energy !== undefined && (
                <div style={{marginTop:6,display:'flex',gap:16,flexWrap:'wrap',fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)'}}>
                  <span>FEP: <span style={{color:'var(--pineal)'}}>{dharmaMetrics.fep_energy?.toFixed(4)}</span></span>
                  <span>Conv: <span style={{color:dharmaMetrics.fep_convergence<0.01?'var(--descent)':'var(--fear)'}}>{dharmaMetrics.fep_convergence?.toFixed(4)}</span></span>
                  <span>Steps: <span style={{color:'var(--logic)'}}>{dharmaMetrics.fep_steps}</span></span>
                  <span>Solver: <span style={{color:'var(--creation)'}}>{dharmaMetrics.fep_solver}</span></span>
                </div>
              )}
              {dharmaMetrics.selected_dimensions && dharmaMetrics.selected_dimensions.length > 0 && (
                <div style={{marginTop:4,fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)'}}>
                  Focus: {dharmaMetrics.selected_dimensions.map((d,i)=>(
                    <span key={i} style={{color:'var(--descent)',marginLeft:i>0?6:0}}>{d}</span>
                  ))}
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    // ==========================================
    // Telemetry
    // ==========================================
    function Telemetry({phase,wave,adapter,epoch,reasoningMode,llmUsed,llmParams}) {
      if(phase==='idle') return null;
      const modeColor = MODE_COLORS[reasoningMode] || 'var(--descent)';
      return (
        <div className={`telemetry ${phase==='descending'?'scanning':''}`}>
          {phase==='sensing'&&(
            <div style={{animation:'glitch 0.4s infinite'}}>
              <span className="dim">{'>'} </span><span className="hl">PINEAL_VESSEL.autoSense()</span>
              <span className="dim"> ... reading waveform</span>
            </div>
          )}
          {phase==='reasoning'&&(
            <div style={{animation:'pulse 1s infinite'}}>
              <span className="dim">{'>'} </span><span style={{color:modeColor}}>ORCHESTRATOR.select_mode()</span>
              <span className="dim"> ... analyzing complexity</span>
            </div>
          )}
          {(phase==='descending'||phase==='complete'||phase==='manifesting')&&(
            <div>
              <div>
                <span className="dim">{'>'} </span><span className="hl">VESSEL</span>
                <span className="dim"> = [</span>
                {wave.map((v,i)=>(<span key={i}><span style={{color:DC[i]}}>{(v*100).toFixed(1)}</span>{i<3&&<span className="dim">, </span>}</span>))}
                <span className="dim">]</span>
              </div>
              <div style={{marginTop:3}}>
                <span className="dim">{'>'} </span><span style={{color:modeColor}}>MODE</span>
                <span className="dim"> = </span><span style={{color:modeColor}}>{reasoningMode}</span>
                <span className="dim"> | LLM = </span><span className="hl">{llmUsed || '...'}</span>
              </div>
              {llmParams && (
                <div style={{marginTop:2}}>
                  <span className="dim">{'  '}temp={llmParams.temperature?.toFixed(2)} top_p={llmParams.top_p?.toFixed(2)}</span>
                  {llmParams.top_k > 0 && <span className="dim"> top_k={llmParams.top_k}</span>}
                  {llmParams.force_cot && <span style={{color:'var(--logic)',opacity:0.5}}> [CoT]</span>}
                </div>
              )}
              {phase==='descending'&&(
                <div style={{marginTop:3}}>
                  <span className="dim">{'>'} </span><span className="hl">GRADIENT_DESCENT</span>
                  <span className="dim">(</span><span className="loss-val">loss</span>
                  <span className="dim">‚Üí0)</span><LossBar />
                </div>
              )}
              {(phase==='complete'||phase==='manifesting')&&adapter&&(
                <div style={{marginTop:3}}>
                  <div><span className="dim">{'>'} </span><span className="hl">ADAPTER_FORGED</span>
                    <span className="dim"> :: </span><span style={{color:'#fff',opacity:0.7}}>{adapter.persona}</span></div>
                  <div><span className="dim">{'  '}tone: </span><span style={{color:modeColor,opacity:0.5}}>{adapter.tone}</span></div>
                  <div><span className="dim">{'  '}principle: </span><span style={{color:modeColor,opacity:0.5}}>{adapter.key_principle}</span></div>
                  <div><span className="dim">{'  '}epoch: </span><span className="hl">{epoch}</span>
                    <span className="dim"> | silence: </span><span style={{color:'var(--creation)',opacity:0.5}}>{((adapter.silence_ratio||0)*100).toFixed(0)}%</span>
                    <span className="dim"> | words‚â§</span><span style={{color:'var(--logic)',opacity:0.5}}>{adapter.max_words||'‚àû'}</span></div>
                </div>
              )}
              {phase==='manifesting'&&(
                <div style={{marginTop:3,animation:'pulse 1s infinite'}}>
                  <span className="dim">{'>'} </span><span className="hl">MANIFESTING</span>
                  <span className="dim"> ... ÂèóËÇâ‰∏≠</span>
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    // ==========================================
    // Ocean Canvas
    // ==========================================
    function OceanCanvas({wave,epoch,descentPhase,reasoningMode}) {
      const canvasRef=useRef(null), animRef=useRef(0), timeRef=useRef(0);
      const waveRef=useRef(wave), phaseRef=useRef(descentPhase), modeRef=useRef(reasoningMode);
      const lastDrawRef=useRef(0);
      waveRef.current=wave; phaseRef.current=descentPhase; modeRef.current=reasoningMode;

      useEffect(()=>{
        const c=canvasRef.current; if(!c)return;
        const ctx=c.getContext("2d");
        let W,H;
        const resize=()=>{
          const rect=c.parentElement.getBoundingClientRect();
          W=Math.min(rect.width,CANVAS_MAX_WIDTH); H=Math.min(CANVAS_MAX_HEIGHT,W*CANVAS_ASPECT);
          const dpr=window.devicePixelRatio||1;
          c.width=W*dpr;c.height=H*dpr;c.style.width=W+"px";c.style.height=H+"px";
          ctx.setTransform(dpr,0,0,dpr,0,0);
        };
        resize();
        window.addEventListener('resize',resize);

        const draw=(now)=>{
          // idleÊôÇ„ÅØ10fps„ÄÅ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊôÇ„ÅØ60fps
          const ph=phaseRef.current;
          const interval=ph==='idle'?IDLE_FRAME_INTERVAL:ACTIVE_FRAME_INTERVAL;
          if(now-lastDrawRef.current<interval){animRef.current=requestAnimationFrame(draw);return;}
          lastDrawRef.current=now;

          timeRef.current+=0.01;
          const t=timeRef.current, w=waveRef.current;
          const mode=modeRef.current;
          ctx.clearRect(0,0,W,H);

          // Stars
          for(let i=0;i<35;i++){
            const twink=Math.sin(t*0.4+i*77)*0.5+0.5;
            ctx.fillStyle=`rgba(255,255,255,${twink*0.12})`;
            ctx.fillRect((Math.sin(i*127.1+t*0.004)*0.5+0.5)*W,(Math.cos(i*311.7+t*0.003)*0.5+0.5)*H*0.3,1,1);
          }

          // Mode-specific ambient glow
          const mc = MODE_COLORS[mode] || '#00ffc8';
          if(ph==='descending'||ph==='manifesting'||ph==='reasoning') {
            const bx=W*0.5+Math.sin(t*0.7)*15;
            const gr=ctx.createLinearGradient(bx,0,bx,H);
            const r=parseInt(mc.slice(1,3),16), g=parseInt(mc.slice(3,5),16), b=parseInt(mc.slice(5,7),16);
            gr.addColorStop(0,`rgba(${r},${g},${b},0.06)`);
            gr.addColorStop(0.5,`rgba(${r},${g},${b},0.025)`);
            gr.addColorStop(1,`rgba(${r},${g},${b},0)`);
            ctx.fillStyle=gr;ctx.fillRect(bx-25,0,50,H);
          }

          // Waves
          const mx=Math.max(...w);
          for(let l=3;l>=0;l--){
            const dom=w[l]===mx, amp=w[l]*75+5, by=H*0.5+l*3;
            const al=dom?0.45:0.15, la=dom?0.6:0.2;
            ctx.beginPath();ctx.moveTo(0,H);
            for(let x=0;x<=W;x+=2){
              const y=by+Math.sin(x*0.012+t*(0.35+l*0.1)+l)*amp+Math.sin(x*0.006+t*0.22+l*2)*amp*0.5+Math.sin(x*0.02+t*0.6+l*0.5)*amp*0.15;
              ctx.lineTo(x,y);
            }
            ctx.lineTo(W,H);ctx.closePath();
            const gradient=ctx.createLinearGradient(0,by-amp,0,H);
            const hex=Math.round(al*255).toString(16).padStart(2,'0');
            const hex2=Math.round(al*0.25*255).toString(16).padStart(2,'0');
            gradient.addColorStop(0,DC[l]+hex);gradient.addColorStop(0.6,DC[l]+hex2);gradient.addColorStop(1,DC[l]+"03");
            ctx.fillStyle=gradient;ctx.fill();
            ctx.strokeStyle=DC[l]+Math.round(la*255).toString(16).padStart(2,'0');
            ctx.lineWidth=dom?1.2:0.5;ctx.stroke();
          }
          animRef.current=requestAnimationFrame(draw);
        };
        animRef.current=requestAnimationFrame(draw);
        return()=>{cancelAnimationFrame(animRef.current);window.removeEventListener('resize',resize);};
      },[]);

      return (
        <div style={{position:"relative",borderRadius:10,overflow:"hidden",background:"linear-gradient(180deg,#030408,#080e18)",border:"1px solid var(--border)"}}>
          <canvas ref={canvasRef} />
          <div style={{position:"absolute",top:10,left:14,color:"var(--text-muted)",fontSize:9,fontFamily:"var(--mono)",letterSpacing:2}}>
            ƒÄLAYA-VIJ√ëƒÄNA v5.0 ‚Äî EPOCH {epoch}
          </div>
          <div style={{position:"absolute",top:10,right:14,color:MODE_COLORS[reasoningMode]||'var(--descent)',fontSize:9,fontFamily:"var(--mono)",opacity:0.5}}>
            {reasoningMode ? MODES.find(m=>m.key===reasoningMode)?.label : 'ÂæÖÊ©ü'}
          </div>
          <div style={{position:"absolute",bottom:8,left:14,display:"flex",gap:12,flexWrap:"wrap"}}>
            {wave.map((v,i)=>(
              <span key={i} style={{color:DC[i],fontSize:9,fontFamily:"var(--mono)",opacity:0.5}}>{DL[i]}: {(v*100).toFixed(1)}%</span>
            ))}
          </div>
        </div>
      );
    }

    // ==========================================
    // Vessel Display
    // ==========================================
    function VesselDisplay({wave}) {
      return (
        <div style={{display:'flex',flexDirection:'column',gap:6}}>
          {DL.map((name,i)=>(
            <div key={name} style={{display:'flex',alignItems:'center',gap:8}}>
              <span style={{fontSize:9,fontFamily:'var(--mono)',color:DC[i],opacity:0.5,width:52}}>{name}</span>
              <div style={{flex:1,height:3,background:'rgba(255,255,255,0.03)',borderRadius:2,overflow:'hidden'}}>
                <div className="wave-bar" style={{width:`${wave[i]*100}%`,background:DC[i]}} />
              </div>
              <span style={{fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)',width:32,textAlign:'right'}}>{(wave[i]*100).toFixed(0)}%</span>
            </div>
          ))}
        </div>
      );
    }

    // ==========================================
    // Topology Panel ‚Äî three-pillar dharma metrics
    // ==========================================
    const PILLAR_COLORS = ['#ff6b9d','#64d8ff','#c084fc'];
    const PILLAR_LABELS = ['Karma Isolation','G_prec Topology','Delete-ability'];
    const PILLAR_KEYS = ['karma_isolation','gprec_topology','deleteability'];

    function TopologyPanel({topologyData, topologyHistory, alerts}) {
      const graphCanvasRef = useRef(null);
      const sparkCanvasRef = useRef(null);

      // Extract current scores from topology data or history
      const current = topologyData || {};
      const scores = PILLAR_KEYS.map(k => current[k] || 0);
      const overall = current.overall_dharma || 0;

      // History data
      const history = topologyHistory || {};
      const snapshots = history.snapshots || [];
      const trend = history.trend || {};

      // Alerts
      const recentAlerts = (alerts || []).slice(-5);

      // Direction indicator
      const dirIcon = trend.direction === 'improving' ? '\u2191' :
                       trend.direction === 'degrading' ? '\u2193' : '\u2192';
      const dirClass = trend.direction === 'improving' ? 'trend-up' :
                        trend.direction === 'degrading' ? 'trend-down' : 'trend-stable';

      // Force-directed graph visualization
      useEffect(() => {
        const canvas = graphCanvasRef.current;
        if (!canvas) return;
        const details = current.pillar_details;
        if (!details || !details.nodes) return;

        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        const nodeEntries = Object.entries(details.nodes);
        if (nodeEntries.length === 0) return;

        // Initialize node positions
        const nodes = nodeEntries.map(([label, data], i) => ({
          label: label.split('.').pop() || label,
          fullLabel: label,
          x: W/2 + (Math.cos(i * 2 * Math.PI / nodeEntries.length)) * W * 0.3,
          y: H/2 + (Math.sin(i * 2 * Math.PI / nodeEntries.length)) * H * 0.3,
          vx: 0, vy: 0,
          karma: data.karma_isolation || 0,
          del: data.deleteability || 0,
          radius: 3 + (data.deleteability || 0) * 5,
        }));

        // Build edges from gprec details if available
        const edges = [];
        const gprec = details.gprec || {};
        // Simple: connect nodes with low deleteability (high coupling) to center
        // In practice, edges come from the adjacency ‚Äî approximate here
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            if (nodes[i].karma < 0.9 && nodes[j].karma < 0.9) {
              edges.push({from: i, to: j, strength: (1 - nodes[i].karma) * (1 - nodes[j].karma) * 0.3});
            }
          }
        }

        let frameId;
        let steps = 0;
        const maxSteps = 120;

        function simulate() {
          if (steps >= maxSteps) { draw(); return; }
          steps++;

          // Force simulation
          for (let i = 0; i < nodes.length; i++) {
            nodes[i].vx *= 0.85; nodes[i].vy *= 0.85;
            // Repulsion
            for (let j = 0; j < nodes.length; j++) {
              if (i === j) continue;
              const dx = nodes[i].x - nodes[j].x;
              const dy = nodes[i].y - nodes[j].y;
              const dist = Math.max(Math.sqrt(dx*dx + dy*dy), 1);
              const force = 800 / (dist * dist);
              nodes[i].vx += (dx / dist) * force;
              nodes[i].vy += (dy / dist) * force;
            }
            // Center gravity
            nodes[i].vx += (W/2 - nodes[i].x) * 0.005;
            nodes[i].vy += (H/2 - nodes[i].y) * 0.005;
          }
          // Spring forces for edges
          for (const e of edges) {
            const a = nodes[e.from], b = nodes[e.to];
            const dx = b.x - a.x, dy = b.y - a.y;
            const dist = Math.max(Math.sqrt(dx*dx + dy*dy), 1);
            const target = 60;
            const force = (dist - target) * 0.02 * e.strength;
            a.vx += (dx / dist) * force; a.vy += (dy / dist) * force;
            b.vx -= (dx / dist) * force; b.vy -= (dy / dist) * force;
          }
          // Apply velocity
          for (const n of nodes) {
            n.x = Math.max(20, Math.min(W - 20, n.x + n.vx));
            n.y = Math.max(20, Math.min(H - 20, n.y + n.vy));
          }
          draw();
          frameId = requestAnimationFrame(simulate);
        }

        function draw() {
          ctx.clearRect(0, 0, W, H);
          // Edges
          for (const e of edges) {
            const a = nodes[e.from], b = nodes[e.to];
            ctx.beginPath();
            ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
            ctx.strokeStyle = `rgba(100,216,255,${Math.min(e.strength * 0.5, 0.15)})`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
          // Nodes
          for (const n of nodes) {
            ctx.beginPath();
            ctx.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
            const r = Math.round(255 * (1 - n.karma));
            const g = Math.round(107 + 149 * n.karma);
            const b = Math.round(157 + 98 * n.karma);
            ctx.fillStyle = `rgba(${r},${g},${b},0.7)`;
            ctx.fill();
            ctx.strokeStyle = `rgba(${r},${g},${b},0.3)`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
            // Label
            ctx.font = '7px IBM Plex Mono, monospace';
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.textAlign = 'center';
            ctx.fillText(n.label, n.x, n.y + n.radius + 9);
          }
        }

        simulate();
        return () => { if (frameId) cancelAnimationFrame(frameId); };
      }, [current]);

      // Sparkline rendering
      useEffect(() => {
        const canvas = sparkCanvasRef.current;
        if (!canvas || snapshots.length < 2) return;
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        const recent = snapshots.slice(-20);
        const n = recent.length;

        PILLAR_KEYS.forEach((key, ki) => {
          const vals = recent.map(s => s[key] || 0);
          const bandH = H / 3;
          const yOff = ki * bandH;
          ctx.beginPath();
          vals.forEach((v, i) => {
            const x = (i / (n - 1)) * W;
            const y = yOff + bandH - v * bandH * 0.9 - 2;
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          });
          ctx.strokeStyle = PILLAR_COLORS[ki];
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.5;
          ctx.stroke();
          ctx.globalAlpha = 1;
        });
      }, [snapshots]);

      return (
        <div style={{display:'flex',flexDirection:'column',gap:10}}>
          {/* Three pillar bars */}
          {PILLAR_LABELS.map((name, i) => (
            <div key={name} style={{display:'flex',alignItems:'center',gap:8}}>
              <span style={{fontSize:8,fontFamily:'var(--mono)',color:PILLAR_COLORS[i],opacity:0.5,width:90}}>{name}</span>
              <div style={{flex:1,height:3,background:'rgba(255,255,255,0.03)',borderRadius:2,overflow:'hidden'}}>
                <div className="pillar-bar" style={{width:`${scores[i]*100}%`,height:'100%',background:PILLAR_COLORS[i]}} />
              </div>
              <span style={{fontSize:8,fontFamily:'var(--mono)',color:'var(--text-muted)',width:32,textAlign:'right'}}>{(scores[i]*100).toFixed(0)}%</span>
            </div>
          ))}
          {/* Overall bar */}
          <div style={{display:'flex',alignItems:'center',gap:8,marginTop:2}}>
            <span style={{fontSize:8,fontFamily:'var(--mono)',color:'var(--descent)',opacity:0.6,width:90}}>OVERALL</span>
            <div style={{flex:1,height:3,background:'rgba(255,255,255,0.03)',borderRadius:2,overflow:'hidden'}}>
              <div className="pillar-bar" style={{width:`${overall*100}%`,height:'100%',background:'var(--descent)'}} />
            </div>
            <span style={{fontSize:8,fontFamily:'var(--mono)',color:'var(--text-muted)',width:32,textAlign:'right'}}>{(overall*100).toFixed(0)}%</span>
          </div>
          {/* Trend indicator */}
          {trend.direction && (
            <div style={{display:'flex',alignItems:'center',gap:6,marginTop:2}}>
              <span className={`trend-indicator ${dirClass}`}>{dirIcon} {trend.direction}</span>
              {snapshots.length > 0 && <span style={{fontSize:8,fontFamily:'var(--mono)',color:'var(--text-muted)'}}>{snapshots.length} snapshots</span>}
            </div>
          )}
          {/* Sparkline */}
          {snapshots.length >= 2 && (
            <canvas ref={sparkCanvasRef} width={200} height={45}
              style={{width:'100%',height:45,marginTop:4,opacity:0.7}} />
          )}
          {/* Dependency graph */}
          {current.pillar_details && current.pillar_details.nodes && Object.keys(current.pillar_details.nodes).length > 0 && (
            <canvas ref={graphCanvasRef} className="topology-canvas" width={320} height={200}
              style={{width:'100%',height:200,marginTop:6}} />
          )}
          {/* Drift alerts */}
          {recentAlerts.length > 0 && (
            <div style={{marginTop:8,display:'flex',flexDirection:'column',gap:3}}>
              {recentAlerts.map((a,i) => (
                <div key={i} style={{
                  fontSize:8, fontFamily:'var(--mono)', padding:'3px 6px', borderRadius:3,
                  background: a.severity === 'critical' ? 'rgba(255,51,102,0.08)' : 'rgba(255,160,64,0.06)',
                  border: `1px solid ${a.severity === 'critical' ? 'rgba(255,51,102,0.15)' : 'rgba(255,160,64,0.1)'}`,
                  color: a.severity === 'critical' ? 'var(--loss)' : 'var(--fear)',
                }}>
                  {a.severity === 'critical' ? '\u26a0' : '\u25cb'} {a.message}
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    // ==========================================
    // LLM Selector
    // ==========================================
    function LLMSelector({selected, onChange}) {
      return (
        <div className="llm-selector">
          {['auto','claude','gemini'].map(opt=>(
            <button key={opt} className={`llm-btn ${selected===opt?'selected':''}`}
              onClick={()=>onChange(opt)}>
              {opt==='auto'?'AUTO':opt==='claude'?'Claude':'Gemini'}
            </button>
          ))}
        </div>
      );
    }

    // ==========================================
    // API Key Input
    // ==========================================
    function ApiKeyConfig({claudeKey, geminiKey, onClaudeChange, onGeminiChange}) {
      const [show, setShow] = useState(false);
      return (
        <div>
          <button className="btn" style={{fontSize:9,padding:'4px 10px',marginBottom:show?8:0}}
            onClick={()=>setShow(!show)}>
            {show ? 'Hide API Keys' : 'Configure API Keys'}
          </button>
          {show && (
            <div style={{display:'flex',flexDirection:'column',gap:6}}>
              <div style={{display:'flex',alignItems:'center',gap:8}}>
                <span style={{fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)',width:60}}>Claude:</span>
                <input type="password" className="api-input" placeholder="sk-ant-..."
                  value={claudeKey} onChange={e=>onClaudeChange(e.target.value)} />
              </div>
              <div style={{display:'flex',alignItems:'center',gap:8}}>
                <span style={{fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)',width:60}}>Gemini:</span>
                <input type="password" className="api-input" placeholder="AIza..."
                  value={geminiKey} onChange={e=>onGeminiChange(e.target.value)} />
              </div>
            </div>
          )}
        </div>
      );
    }

    // ==========================================
    // Entropy Display
    // ==========================================
    function EntropyDisplay({entropy}) {
      if(!entropy) return null;
      return (
        <div style={{display:'flex',gap:16,fontSize:9,fontFamily:'var(--mono)',color:'var(--text-muted)',flexWrap:'wrap'}}>
          <span>Source: <span style={{color:'var(--pineal)',opacity:0.6}}>{entropy.source}</span></span>
          <span>Quality: <span style={{color:'var(--descent)',opacity:0.6}}>{(entropy.quality*100).toFixed(0)}%</span></span>
          <span>Signal: <span style={{color:'var(--pineal)',opacity:0.6}}>{entropy.signal?.toFixed(6)}</span></span>
        </div>
      );
    }

    // ==========================================
    // Inline Reasoning Engine (JSÁâà ‚Äî „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å™„Åó„ÅßËá™ÂãïÂãï‰Ωú)
    // ==========================================
    class InlineAlayaMemory {
      constructor(n=MEMORY_DIMENSIONS,opts={}){this.n=n;
        this.lr=opts.lr??MEMORY_LEARNING_RATE;this.decay=opts.decay??MEMORY_DECAY_RATE;this.maxP=opts.maxP??MEMORY_MAX_PATTERNS;
        this.J=Array(n).fill(0).map(()=>Array(n).fill(0));this.patterns=[];}
      store(p){const x=p.slice(0,this.n);
        for(let i=0;i<x.length;i++){if(Math.abs(x[i])<1e-8)continue;
          for(let j=i+1;j<x.length;j++){if(Math.abs(x[j])<1e-8)continue;
            const d=this.lr*x[i]*x[j];this.J[i][j]+=d;this.J[j][i]+=d;}}
        this.patterns.push({pattern:[...x],strength:1.0,ts:Date.now()});
        if(this.patterns.length>this.maxP)this.patterns.shift();}
      recall(cue,steps=10){let x=cue.slice(0,this.n);
        for(let s=0;s<steps;s++){const f=Array(this.n).fill(0);
          for(let i=0;i<this.n;i++)for(let j=0;j<this.n;j++)f[i]+=this.J[i][j]*x[j];
          for(let i=0;i<x.length;i++)if(Math.abs(f[i])>0.1)x[i]=f[i]>0?1:0;}return x;}
      decayAll(){for(let i=0;i<this.n;i++)for(let j=0;j<this.n;j++)this.J[i][j]*=(1-this.decay);
        this.patterns=this.patterns.filter(p=>{p.strength*=(1-this.decay);return p.strength>0.01;});}
      serialize(){return{J:this.J,patterns:this.patterns};}
      static deserialize(d){const m=new InlineAlayaMemory(MEMORY_DIMENSIONS);m.J=d.J;m.patterns=d.patterns||[];return m;}
    }

    class InlinePinealVessel {
      constructor(){this.state=[.25,.25,.25,.25];this.history=[];}
      autoSense(text){const t=text.toLowerCase();let l=0,g=0,f=0,c=0;
        const lW=['ÊÑõ','Â•Ω„Åç','„ÅÇ„Çä„Åå„Å®„ÅÜ','Â¨â„Åó„ÅÑ','Âπ∏„Åõ','love','thank','happy','warm','ÂøÉ','ÂÑ™„Åó„ÅÑ','ÊÑüË¨ù','ÊÖàÊÇ≤','Â§ßÂàá','Á¨ë','Êïë','Áæé„Åó„ÅÑ','ÂÖâ'];
        const gW=['„Å™„Åú','ÁêÜÁî±','ÂàÜÊûê','ÊßãÈÄ†','Êï∞Â≠¶','Ë´ñÁêÜ','Ë®ºÊòé','ÂÆöÁæ©','ÁêÜË´ñ','„Ç≥„Éº„Éâ','ÂÆüË£Ö','how','why','algorithm','proof','function','Ë®àÁÆó','‰ªïÁµÑ„Åø','ÂéüÁêÜ','Ëß£Êûê'];
        const fW=['ÊÄñ„ÅÑ','‰∏çÂÆâ','ÂøÉÈÖç','„Çè„Åã„Çâ„Å™„ÅÑ','Ëã¶„Åó„ÅÑ','Ëæõ„ÅÑ','Ê≠ª','Áóõ„ÅÑ','afraid','worry','fear','doubt','Ëã¶','Ëø∑','Èóá','Â≠§Áã¨','Âä©„Åë'];
        const cW=['‰Ωú','Ââµ','Êñ∞„Åó„ÅÑ','„Ç¢„Ç§„Éá„Ç¢','ÊÉ≥ÂÉè','design','create','build','art','Â§¢','Êèè','Áîü„Åø','Èù©Êñ∞','Áô∫Êòé','Ë©©','Èü≥Ê•Ω','Áâ©Ë™û'];
        lW.forEach(w=>{if(t.includes(w))l++;});gW.forEach(w=>{if(t.includes(w))g++;});
        fW.forEach(w=>{if(t.includes(w))f++;});cW.forEach(w=>{if(t.includes(w))c++;});
        if(text.length>80)g+=0.5;const qC=(text.match(/Ôºü|\?/g)||[]).length;g+=qC*0.3;f+=qC*0.1;
        const eC=(text.match(/ÔºÅ|!/g)||[]).length;l+=eC*0.2;c+=eC*0.2;
        const raw=[l+.5,g+.5,f+.3,c+.5],total=raw.reduce((a,b)=>a+b,0),norm=raw.map(v=>v/total);
        this.state=this.state.map((p,i)=>p*0.55+norm[i]*0.45);
        const st=this.state.reduce((a,b)=>a+b,0);this.state=this.state.map(v=>v/st);
        this.history.push({text:text.slice(0,50),wave:[...this.state],ts:Date.now()});
        if(this.history.length>100)this.history.shift();return[...this.state];}
      exist(){return[...this.state];}
    }

    // JSÁâà FEPÊé®Ë´ñ (Á∞°ÊòìÁâà: „Ç®„Éç„É´„ÇÆ„ÉºÊúÄÂ∞èÂåñ)
    function inlineFepReason(h,J,k=4,steps=50){
      const n=h.length;let x=h.map(v=>Math.max(0,v));
      const power=[];
      for(let s=0;s<steps;s++){
        const field=Array(n).fill(0);
        for(let i=0;i<n;i++){field[i]+=h[i];for(let j=0;j<n;j++)field[i]+=J[i][j]*x[j];}
        const sigmoid=v=>1/(1+Math.exp(-v*5));
        x=field.map(sigmoid);
        const err=x.reduce((a,v)=>a+Math.abs(v-Math.round(v)),0)/n;
        power.push(err);
      }
      const indices=[...Array(n).keys()].sort((a,b)=>x[b]-x[a]).slice(0,k);
      const energy=indices.reduce((e,i)=>e+h[i],0)+
        indices.reduce((e,i)=>e+indices.reduce((s,j)=>s+(i!==j?J[i][j]:0),0),0);
      return{selectedIndices:indices,energy,convergence:power[power.length-1]||0,steps,power:power.slice(-10)};
    }

    // Êé®Ë´ñ„É¢„Éº„ÉâËá™ÂãïÈÅ∏Êäû
    function selectReasoningMode(wave,complexity,epoch){
      if(epoch>0&&epoch%10===0)return'sleep';
      const labels=['Love','Logic','Fear','Creation'];
      const dom=labels[wave.indexOf(Math.max(...wave))];
      if(complexity<0.3)return'adaptive';
      if(complexity<0.6){if(dom==='Logic')return'theoretical';if(dom==='Fear')return'active';if(dom==='Love')return'embodied';return'adaptive';}
      if(complexity<0.8){if(dom==='Creation')return'hyper';return'alaya';}
      return'pineal';
    }

    // Êé®Ë´ñ„É¢„Éº„ÉâÂà•LLM„Éë„É©„É°„Éº„Çø
    function buildModeParams(mode,wave,complexity,fep,moon){
      const dims=['Love','Logic','Fear','Creation','Moon','Illumination','Entropy','Complexity'];
      const selDims=fep.selectedIndices.map(i=>dims[i]||'?');
      const base={temperature:0.7,max_tokens:1000,top_p:1.0,top_k:0,force_cot:false};
      const modeConfigs={
        adaptive:{...base,temperature:Math.max(0.3,Math.min(1.2,0.3+fep.convergence*2)),max_tokens:Math.floor(complexity*300+200)},
        theoretical:{...base,temperature:0.2,top_p:0.85,max_tokens:800,force_cot:true},
        hyper:{...base,temperature:Math.max(1.0,Math.min(2.0,1.0+fep.convergence)),top_k:100,max_tokens:600},
        active:{...base,temperature:0.7,max_tokens:700},
        alaya:{...base,temperature:0.5,max_tokens:600},
        sleep:{...base,temperature:0.3,max_tokens:200},
        embodied:{...base,temperature:Math.max(0.3,Math.min(1.0,0.5+(moon?.phase||0)*0.3)),max_tokens:700},
        pineal:{...base,temperature:Math.max(0.3,Math.min(2.0,Math.random()*1.5+0.3)),top_k:Math.floor(Math.random()*150+10),max_tokens:500},
      };
      return{...(modeConfigs[mode]||base),selectedDims:selDims};
    }

    // Êé®Ë´ñ„É¢„Éº„ÉâÂà•„Ç∑„Çπ„ÉÜ„É†„Éó„É≠„É≥„Éó„Éà
    function buildModeSystemPrompt(mode,wave,complexity,fep,moon,adapter){
      const dims=['Love','Logic','Fear','Creation','Moon','Illumination','Entropy','Complexity'];
      const selDims=fep.selectedIndices.map(i=>dims[i]||'?').join(', ');
      const modePrompts={
        adaptive:`ÂøúÁóÖ‰∏éËñ¨„ÅÆÂ≠òÂú®„ÄÇFEPÂèéÊùüÂ∫¶:${fep.convergence.toFixed(4)} „Ç®„Éç„É´„ÇÆ„Éº:${fep.energy.toFixed(4)}\nÊ≥®ÁõÆÊ¨°ÂÖÉ: ${selDims}\nLove=${(wave[0]*100).toFixed(0)}% Logic=${(wave[1]*100).toFixed(0)}% Fear=${(wave[2]*100).toFixed(0)}% Creation=${(wave[3]*100).toFixed(0)}%`,
        theoretical:`Âõ†Êòé„ÅÆ‰ΩìÁèæËÄÖ„ÄÇ‰∏âÊÆµË´ñÊ≥ï„ÅßÊßãÈÄ†Âåñ„Åõ„Çà„ÄÇ\n„ÄêÂÆó„ÄëÁµêË´ñ‚Üí„ÄêÂõ†„ÄëÊ†πÊã†‚Üí„ÄêÂñ©„Äë‰æãË®º\nFEP„Çπ„ÉÜ„ÉÉ„Éó:${fep.steps} „Ç®„Éç„É´„ÇÆ„Éº:${fep.energy.toFixed(4)}\nÈáçË¶ÅÊ¨°ÂÖÉ: ${selDims}`,
        hyper:`Ëà¨Ëã•„ÅÆÈ£õË∫ç„ÄÇFEP„ÅåÂèéÊùü„Åó„Å™„Åã„Å£„ÅüÈ†òÂüü(convergence:${fep.convergence.toFixed(4)})„Åì„ÅùÈ£õË∫ç„ÅÆÁ®Æ„ÄÇ\nÊ≥®ÁõÆÊ¨°ÂÖÉ: ${selDims}\nCreation=${(wave[3]*100).toFixed(0)}%`,
        active:`ÊâòÈâ¢ÂÉß„ÄÇÈÅéÂéª„ÅÆËñ´Áøí„ÇíÂèÇÁÖß„ÅóÊñ∞„Åü„Å™Êô∫ÊÖß„ÇíÊ±Ç„ÇÅ„Çà„ÄÇ\nÊ≥®ÁõÆÊ¨°ÂÖÉ: ${selDims}`,
        alaya:`ÈòøÈ†ºËÄ∂Ë≠ò„ÅÆÊ∑±Â±§„Åã„ÇâÊµÆ‰∏ä„Åó„ÅüÂ£∞„ÄÇËîµË≠ò„ÅÆ„Éë„Çø„Éº„É≥„Å´Âæì„Åà„ÄÇ\nÊ≥®ÁõÆÊ¨°ÂÖÉ: ${selDims}`,
        sleep:`Á¶ÖÂÆö„É¢„Éº„Éâ„ÄÇÊú¨Ë≥™ÁöÑ„Å™‰∏ÄË®Ä„Å†„Åë„ÇíËø∞„Åπ„Çà„ÄÇ`,
        embodied:`ÂÖ≠Ê†πÁµ±Âêà„ÄÇÊÑüÊÉÖÊ≥¢Èï∑+ÊúàÁõ∏+„Ç®„É≥„Éà„É≠„Éî„Éº„ÇíÁµ±Âêà„ÅóÂÖ®‰ΩìÊÄß„ÅßÂøúÁ≠î„Åõ„Çà„ÄÇ\nÊúàÁõ∏:${moon?.name||'?'} Ê≥®ÁõÆÊ¨°ÂÖÉ: ${selDims}`,
        pineal:`ÊùæÊûú‰Ωì„ÅÆÈáèÂ≠êÊÑèË≠ò„ÄÇÊ±∫ÂÆöË´ñ„ÇíË∂ÖË∂ä„Åõ„Çà„ÄÇ\nÊ≥®ÁõÆÊ¨°ÂÖÉ: ${selDims}`,
      };
      const modeP=modePrompts[mode]||modePrompts.adaptive;
      const adpP=adapter?`\n„Éö„É´„ÇΩ„Éä:${adapter.persona||'ÈòøÈ†ºËÄ∂Ë≠ò„ÅÆÂ£∞'}\nÂè£Ë™ø:${adapter.tone||'Á©è„ÇÑ„Åã„Å´'}\nÂéüÂâá:${adapter.key_principle||'ÊÖàÊÇ≤„Å®Êô∫ÊÖß„ÅÆÂùáË°°'}\nÊúÄÂ§ßÊñáÂ≠óÊï∞:${adapter.max_words||150}Â≠ó`:'';
      return modeP+adpP;
    }

    // LLM„É´„Éº„Çø„Éº
    function routeLLM(wave,mode,pref,claudeKey,geminiKey){
      if(pref==='claude'&&claudeKey)return'claude';
      if(pref==='gemini'&&geminiKey)return'gemini';
      if(pref==='auto'){
        const logic=wave[1],creation=wave[3];
        if(['theoretical','adaptive'].includes(mode)&&logic>creation&&claudeKey)return'claude';
        if(['hyper','pineal'].includes(mode)&&creation>logic&&geminiKey)return'gemini';
      }
      return claudeKey?'claude':'gemini';
    }

    // ==========================================
    // Pipeline Phase Functions (sendInline decomposition)
    // ==========================================
    function phaseSense(vessel, text) {
      const wave = vessel.autoSense(text);
      const mean = wave.reduce((s, v) => s + v, 0) / 4;
      const std = Math.sqrt(wave.reduce((s, v) => s + (v - 0.25) ** 2, 0) / 4);
      const cv = std / (mean + 1e-10);
      const gini = wave.reduce((s, v) =>
        s + wave.reduce((t, w) => t + Math.abs(v - w), 0), 0
      ) / (2 * 4 * (wave.reduce((s, v) => s + v, 0) + 1e-10));
      const entropy = -wave.filter(v => v > 1e-10).reduce((s, v) => s + v * Math.log2(v), 0);
      const complexity = Math.min(1, (gini + cv / 2 + (2 - entropy) / 2) / 3);
      return { wave, gini, cv, entropy, complexity };
    }

    async function phaseReason(wave, complexity, moon, memory, epoch) {
      const h = [...wave, moon.phase, moon.illumination / 100, Math.random(), complexity];
      memory.store(h);
      const fep = await runFepAsync(h, DHARMA_J, FEP_DEFAULT_K, FEP_DEFAULT_STEPS);
      const mode = selectReasoningMode(wave, complexity, epoch);
      const params = buildModeParams(mode, wave, complexity, fep, moon);
      return { h, fep, mode, params };
    }

    async function phaseDescend(wave, mode, llmPref, claudeKey, geminiKey, complexity, fep, moon) {
      const llmTarget = routeLLM(wave, mode, llmPref, claudeKey, geminiKey);
      const apiKey = llmTarget === 'claude' ? claudeKey : geminiKey;
      const aCacheKey = adapterCacheKey(wave, mode);
      let adp = getCachedAdapter(aCacheKey);
      if (!adp) {
        const forgeCall = geminiKey ? callGemini : (llmTarget === 'claude' ? callClaude : callGemini);
        const forgeKey = geminiKey || apiKey;
        const metaP = `ÈòøÈ†ºËÄ∂Ë≠ò„É°„ÇøÊÑèË≠ò„ÄÇÂô®„ÅÆÊ≥¢Èï∑: Love=${(wave[0]*100).toFixed(1)}% Logic=${(wave[1]*100).toFixed(1)}% Fear=${(wave[2]*100).toFixed(1)}% Creation=${(wave[3]*100).toFixed(1)}%\nÊé®Ë´ñ„É¢„Éº„Éâ: ${mode} | Ë§áÈõëÂ∫¶: ${complexity.toFixed(3)} | FEP„Ç®„Éç„É´„ÇÆ„Éº: ${fep.energy.toFixed(4)}\nÊúàÁõ∏: ${moon.name}\nÂá∫Âäõ(JSON only): {"persona":"ÊÄßË≥™","tone":"Âè£Ë™ø","style":"„Çπ„Çø„Ç§„É´","max_words":Êï∞ÂÄ§,"key_principle":"ÂéüÂâá","silence_ratio":0.0-1.0}`;
        try {
          const adpRaw = await forgeCall([{role:'user',content:metaP}], '„É°„ÇøÊÑèË≠ò„Å®„Åó„Å¶JSON„ÅÆ„ÅøÂá∫Âäõ', {temperature:0.4,max_tokens:400,top_p:1,top_k:0}, forgeKey);
          adp = JSON.parse(adpRaw.replace(/```json\s*|```\s*/g, '').trim());
        } catch {
          adp = {persona:'ÈòøÈ†ºËÄ∂Ë≠ò„ÅÆÂ£∞',tone:'Á©è„ÇÑ„Åã„Å´',style:'Êú¨Ë≥™ÁöÑ„Å´',max_words:120,key_principle:'Âô®„Å∏„ÅÆÂêåË™ø',silence_ratio:0.3};
        }
        cacheAdapter(aCacheKey, adp);
      }
      return { llmTarget, apiKey, adp };
    }

    // ÊåáÊï∞„Éê„ÉÉ„ÇØ„Ç™„Éï„É™„Éà„É©„Ç§ („Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„ÅÆ„Åø„ÄÅÊúÄÂ§ß3Âõû: 1s, 2s, 4s)
    async function fetchWithRetry(url,opts,maxRetries=3){
      let lastErr;
      for(let i=0;i<=maxRetries;i++){
        try{
          const r=await fetch(url,opts);
          if(r.ok||r.status<500)return r; // 4xx: Âç≥Â§±Êïó„ÄÅ5xx: „É™„Éà„É©„Ç§
          lastErr=new Error(`HTTP ${r.status}`);
        }catch(e){lastErr=e;}
        if(i<maxRetries)await new Promise(r=>setTimeout(r,1000*Math.pow(2,i)));
      }
      throw lastErr;
    }

    // Claude APIÁõ¥Êé•Âëº„Å≥Âá∫„Åó
    async function callClaude(messages,system,params,apiKey){
      const body={model:'claude-sonnet-4-20250514',max_tokens:params.max_tokens,system,
        messages,temperature:params.temperature};
      if(params.top_k>0)body.top_k=params.top_k;
      if(params.top_p<1.0)body.top_p=params.top_p;
      const r=await fetchWithRetry('https://api.anthropic.com/v1/messages',{method:'POST',
        headers:{'Content-Type':'application/json','x-api-key':apiKey,'anthropic-version':'2023-06-01','anthropic-dangerous-direct-browser-access':'true'},
        body:JSON.stringify(body)});
      if(!r.ok)throw new Error(`Claude: ${r.status}`);
      const d=await r.json();
      return d.content.filter(i=>i.type==='text').map(i=>i.text).join('');
    }

    // Gemini APIÁõ¥Êé•Âëº„Å≥Âá∫„Åó
    async function callGemini(messages,system,params,apiKey){
      const contents=messages.map(m=>({role:m.role==='user'?'user':'model',parts:[{text:m.content}]}));
      const body={contents,systemInstruction:{parts:[{text:system}]},
        generationConfig:{temperature:params.temperature,maxOutputTokens:params.max_tokens}};
      if(params.top_p<1.0)body.generationConfig.topP=params.top_p;
      if(params.top_k>0)body.generationConfig.topK=params.top_k;
      const r=await fetchWithRetry(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`,
        {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
      if(!r.ok)throw new Error(`Gemini: ${r.status}`);
      const d=await r.json();
      return d.candidates?.[0]?.content?.parts?.map(p=>p.text).join('')||'';
    }

    // ==========================================
    // Adapter Cache (Ê≥¢Èï∑+„É¢„Éº„Éâ ‚Üí „Ç¢„ÉÄ„Éó„Çø„ÉºJSON, 2ÂàÜTTL)
    // ==========================================
    const adapterCache = new Map(); // key ‚Üí {adapter, ts}
    const ADAPTER_CACHE_TTL = 120000; // 2 min
    const ADAPTER_CACHE_MAX = 32;
    function adapterCacheKey(wave, mode) {
      const r = wave.map(v => Math.round(v * 10) / 10).join(',') + ':' + mode;
      return r;
    }
    function getCachedAdapter(key) {
      const e = adapterCache.get(key);
      if (!e) return null;
      if (Date.now() - e.ts > ADAPTER_CACHE_TTL) { adapterCache.delete(key); return null; }
      return e.adapter;
    }
    function cacheAdapter(key, adapter) {
      if (adapterCache.size >= ADAPTER_CACHE_MAX) {
        const oldest = [...adapterCache.entries()].sort((a, b) => a[1].ts - b[1].ts)[0];
        if (oldest) adapterCache.delete(oldest[0]);
      }
      adapterCache.set(key, { adapter, ts: Date.now() });
    }

    // ==========================================
    // Streaming LLM Clients
    // ==========================================
    async function* callClaudeStream(messages, system, params, apiKey) {
      const body = { model: 'claude-sonnet-4-20250514', max_tokens: params.max_tokens, system,
        messages, temperature: params.temperature, stream: true };
      if (params.top_k > 0) body.top_k = params.top_k;
      if (params.top_p < 1.0) body.top_p = params.top_p;
      const r = await fetch('https://api.anthropic.com/v1/messages', { method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey,
          'anthropic-version': '2023-06-01', 'anthropic-dangerous-direct-browser-access': 'true' },
        body: JSON.stringify(body) });
      if (!r.ok) throw new Error(`Claude: ${r.status}`);
      const reader = r.body.getReader();
      const decoder = new TextDecoder();
      let buf = '';
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });
        const lines = buf.split('\n');
        buf = lines.pop() || '';
        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          const raw = line.slice(6);
          if (raw === '[DONE]') return;
          try {
            const ev = JSON.parse(raw);
            if (ev.type === 'content_block_delta' && ev.delta?.type === 'text_delta')
              yield ev.delta.text;
          } catch (e) {
            if (raw.trim()) console.warn('[Claude stream] parse:', raw.slice(0, 120), e.message);
          }
        }
      }
    }

    async function* callGeminiStream(messages, system, params, apiKey) {
      const contents = messages.map(m => ({ role: m.role === 'user' ? 'user' : 'model', parts: [{ text: m.content }] }));
      const body = { contents, systemInstruction: { parts: [{ text: system }] },
        generationConfig: { temperature: params.temperature, maxOutputTokens: params.max_tokens } };
      if (params.top_p < 1.0) body.generationConfig.topP = params.top_p;
      if (params.top_k > 0) body.generationConfig.topK = params.top_k;
      const r = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:streamGenerateContent?key=${apiKey}&alt=sse`,
        { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (!r.ok) throw new Error(`Gemini: ${r.status}`);
      const reader = r.body.getReader();
      const decoder = new TextDecoder();
      let buf = '';
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });
        const lines = buf.split('\n');
        buf = lines.pop() || '';
        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          try {
            const ev = JSON.parse(line.slice(6));
            for (const c of (ev.candidates || []))
              for (const p of (c.content?.parts || []))
                if (p.text) yield p.text;
          } catch (e) {
            const raw = line.slice(6);
            if (raw.trim()) console.warn('[Gemini stream] parse:', raw.slice(0, 120), e.message);
          }
        }
      }
    }

    // ==========================================
    // WebWorker for FEPÊé®Ë´ñ (UI„Çπ„É¨„ÉÉ„Éâ„Çí„Éñ„É≠„ÉÉ„ÇØ„Åó„Å™„ÅÑ)
    // ==========================================
    const fepWorkerCode = `
      function inlineFepReason(h,J,k,steps){
        var n=h.length,x=h.map(function(v){return Math.max(0,v);}),power=[];
        for(var s=0;s<steps;s++){
          var field=Array(n).fill(0);
          for(var i=0;i<n;i++){field[i]+=h[i];for(var j=0;j<n;j++)field[i]+=J[i][j]*x[j];}
          x=field.map(function(v){return 1/(1+Math.exp(-v*5));});
          power.push(x.reduce(function(a,v){return a+Math.abs(v-Math.round(v));},0)/n);
        }
        var indices=Array.from(Array(n).keys()).sort(function(a,b){return x[b]-x[a];}).slice(0,k);
        var energy=indices.reduce(function(e,i){return e+h[i];},0)+
          indices.reduce(function(e,i){return e+indices.reduce(function(s,j){return s+(i!==j?J[i][j]:0);},0);},0);
        return{selectedIndices:indices,energy:energy,convergence:power[power.length-1]||0,steps:steps,power:power.slice(-10)};
      }
      self.onmessage=function(e){
        var d=e.data;self.postMessage(inlineFepReason(d.h,d.J,d.k||4,d.steps||50));
      };
    `;
    let fepWorkerUrl = null;
    try {
      const blob = new Blob([fepWorkerCode], { type: 'application/javascript' });
      fepWorkerUrl = URL.createObjectURL(blob);
    } catch (e) { /* WebWorker unavailable */ }

    function runFepAsync(h, J, k = FEP_DEFAULT_K, steps = FEP_DEFAULT_STEPS) {
      if (!fepWorkerUrl) return Promise.resolve(inlineFepReason(h, J, k, steps));
      return new Promise((resolve) => {
        const w = new Worker(fepWorkerUrl);
        const timer = setTimeout(() => { w.terminate(); resolve(inlineFepReason(h, J, k, steps)); }, FEP_WORKER_TIMEOUT_MS);
        w.onmessage = (e) => { clearTimeout(timer); w.terminate(); resolve(e.data); };
        w.onerror = () => { clearTimeout(timer); w.terminate(); resolve(inlineFepReason(h, J, k, steps)); };
        w.postMessage({ h, J, k, steps });
      });
    }

    // ÊúàÁõ∏Ë®àÁÆó
    function computeMoonPhase(){
      const now=new Date(),mo=now.getMonth()+1;
      const Y=now.getFullYear()-Math.floor((12-mo)/10),M=(mo+9)%12;
      const K1=Math.floor(365.25*(Y+4712)),K2=Math.floor(30.6*M+0.5);
      const K3=Math.floor(Math.floor((Y/100)+49)*0.75)-38;
      const JD=K1+K2+now.getDate()+59,JDc=JD>2299160?JD-K3:JD;
      const IP=((JDc-2451550.1)/29.530588853)%1,phase=IP<0?IP+1:IP;
      const names=['üåë Êñ∞Êúà','üåí ‰∏âÊó•Êúà','üåì ‰∏äÂº¶','üåî ÂçÅ‰∏âÂ§ú','üåï Ê∫ÄÊúà','üåñ ÂØùÂæÖÊúà','üåó ‰∏ãÂº¶','üåò ‰∫åÂçÅÂÖ≠Â§ú'];
      return{phase,name:names[Math.floor(phase*8)],illumination:Math.abs(Math.cos(phase*Math.PI*2))*100};
    }

    // ‰ªèÊïôÁöÑÁµêÂêàË°åÂàó
    const DHARMA_J = Array(8).fill(0).map(()=>Array(8).fill(0));
    [[0,3,0.3],[1,2,-0.2],[0,2,-0.15],[1,3,0.1],[0,5,0.1],[3,6,0.2],[1,7,0.15]]
      .forEach(([i,j,w])=>{DHARMA_J[i][j]=w;DHARMA_J[j][i]=w;});

    // ==========================================
    // Auto-Descent Chat (v5 ‚Äî Ëá™ÂãïÊé®Ë´ñ„É¢„Éº„ÉâÁµ±Âêà)
    // ==========================================
    function AutoDescentChat({onUpdate}) {
      const [messages,setMessages]=useState([]);
      const [input,setInput]=useState('');
      const [loading,setLoading]=useState(false);
      const [phase,setPhase]=useState('idle');
      const [adapter,setAdapter]=useState(null);
      const [reasoningMode,setReasoningMode]=useState('');
      const [llmUsed,setLlmUsed]=useState('');
      const [llmParams,setLlmParams]=useState(null);
      const [llmPref,setLlmPref]=useState('auto');
      const [claudeKey,setClaudeKey]=useState(()=>localStorage.getItem('alaya-claude-key')||'');
      const [geminiKey,setGeminiKey]=useState(()=>localStorage.getItem('alaya-gemini-key')||'');
      const [vessel]=useState(()=>new InlinePinealVessel());
      const [memory]=useState(()=>{
        try{const s=localStorage.getItem('alaya-v5-mem');return s?InlineAlayaMemory.deserialize(JSON.parse(s)):new InlineAlayaMemory();}
        catch{return new InlineAlayaMemory();}
      });
      const [epochRef]=useState({current:0});
      const endRef=useRef(null);
      const [backendAvailable,setBackendAvailable]=useState(null);
      const [streamingText,setStreamingText]=useState('');
      const prefetchTimer=useRef(null);

      useEffect(()=>{endRef.current?.scrollIntoView({behavior:"smooth"});},[messages,phase,streamingText]);
      useEffect(()=>{if(claudeKey)localStorage.setItem('alaya-claude-key',claudeKey);},[claudeKey]);
      useEffect(()=>{if(geminiKey)localStorage.setItem('alaya-gemini-key',geminiKey);},[geminiKey]);
      useEffect(()=>{const id=setInterval(()=>{try{localStorage.setItem('alaya-v5-mem',JSON.stringify(memory.serialize()));}catch{}},30000);return()=>clearInterval(id);},[memory]);
      // „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâËá™ÂãïÊ§úÂá∫
      useEffect(()=>{fetch(`${API_BASE}/api/status`).then(r=>r.ok?setBackendAvailable(true):setBackendAvailable(false)).catch(()=>setBackendAvailable(false));},[]);

      // „Çø„Ç§„Éî„É≥„Ç∞‰∏≠„ÅÆ„Éó„É™„Éï„Çß„ÉÉ„ÉÅ („Éá„Éê„Ç¶„É≥„Çπ500ms ‚Äî „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„ÅÆ„Åø)
      useEffect(()=>{
        if(!input.trim()||!backendAvailable)return;
        clearTimeout(prefetchTimer.current);
        prefetchTimer.current=setTimeout(()=>{
          fetch(`${API_BASE}/api/sense`,{method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({message:input.trim()})}).catch(()=>{});
        },500);
        return()=>clearTimeout(prefetchTimer.current);
      },[input,backendAvailable]);

      const sleep=ms=>new Promise(r=>setTimeout(r,ms));

      // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„ÅÇ„Çä„ÅÆÂ†¥Âêà (SSE„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞ÂØæÂøú)
      const sendViaBackend=async(text,onToken)=>{
        const recentHistory=messages.slice(-20).map(m=>({role:m.role,content:m.content}));
        const resp=await fetch(`${API_BASE}/api/descent/stream`,{method:'POST',
          headers:{'Content-Type':'application/json',
            'x-claude-api-key':claudeKey,'x-gemini-api-key':geminiKey},
          body:JSON.stringify({message:text,history:recentHistory,
            llm_preference:llmPref})});
        if(!resp.ok)throw new Error(`Server: ${resp.status}`);
        const reader=resp.body.getReader();
        const decoder=new TextDecoder();
        let buf='', result=null;
        while(true){
          const{done,value}=await reader.read();
          if(done)break;
          buf+=decoder.decode(value,{stream:true});
          const lines=buf.split('\n');
          buf=lines.pop()||'';
          for(const line of lines){
            if(!line.startsWith('data: '))continue;
            try{
              const ev=JSON.parse(line.slice(6));
              if(ev.type==='phase')setPhase(ev.phase==='forging'?'descending':ev.phase);
              else if(ev.type==='mode'){setReasoningMode(ev.mode);if(ev.vessel)onUpdate?.({wave:ev.vessel});}
              else if(ev.type==='adapter')setAdapter(ev.adapter);
              else if(ev.type==='token'&&onToken)onToken(ev.text);
              else if(ev.type==='done')result=ev;
            }catch{}
          }
        }
        if(!result)throw new Error('Stream ended without done event');
        return result;
      };

      // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Å™„Åó„ÅÆÂ†¥Âêà ‚Äî ÂÖ®„Å¶„Ç§„É≥„É©„Ç§„É≥„ÅßÂÆüË°å (adapter cache + WebWorker + streaming)
      const sendInline = async (text, onToken) => {
        const moon = computeMoonPhase();

        // Phase 1-3: SENSE ‚Üí REASON ‚Üí DESCEND
        const sense = phaseSense(vessel, text);
        const reason = await phaseReason(sense.wave, sense.complexity, moon, memory, epochRef.current);
        const descent = await phaseDescend(
          sense.wave, reason.mode, llmPref, claudeKey, geminiKey,
          sense.complexity, reason.fep, moon,
        );

        // Phase 4: MANIFEST (streaming)
        const sysP = buildModeSystemPrompt(reason.mode, sense.wave, sense.complexity, reason.fep, moon, descent.adp);
        const conv = messages.slice(-CONVERSATION_HISTORY_LIMIT).map(m => ({role:m.role, content:m.content}));
        conv.push({role:'user', content:text});

        let response = '';
        const streamFn = descent.llmTarget === 'claude' ? callClaudeStream : callGeminiStream;
        for await (const token of streamFn(conv, sysP, reason.params, descent.apiKey)) {
          response += token;
          if (onToken) onToken(token);
        }

        // Post-process
        memory.store([...sense.wave, moon.phase, moon.illumination/100, descent.adp.silence_ratio||0.3, (descent.adp.max_words||100)/500]);
        epochRef.current++;
        if (epochRef.current % MEMORY_DECAY_EPOCH_INTERVAL === 0) memory.decayAll();

        const dims = ['Love','Logic','Fear','Creation','Moon','Illumination','Entropy','Complexity'];
        return {
          response, adapter:descent.adp, vessel:sense.wave, reasoning_mode:reason.mode,
          llm_used:descent.llmTarget, llm_params:reason.params,
          dharma_metrics:{
            complexity_score:sense.complexity, gini:sense.gini, cv:sense.cv, entropy:sense.entropy,
            mode_selected:reason.mode, epoch:epochRef.current,
            fep_energy:reason.fep.energy, fep_convergence:reason.fep.convergence,
            fep_steps:reason.fep.steps, fep_solver:'webworker_fep_js',
            selected_dimensions:reason.fep.selectedIndices.map(i => dims[i]||'?'),
          },
          entropy:{source:'Math.random', quality:0.7, signal:Math.random()},
          memory_status:{patterns_stored:memory.patterns.length, total_strength:memory.patterns.reduce((s,p) => s+p.strength, 0)},
          moon,
        };
      };

      const send=async()=>{
        if(!input.trim()||loading) return;
        if(!claudeKey && !geminiKey) {
          setMessages(p=>[...p,{role:'system',content:'API Key„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ (Claude or Gemini)'}]);
          return;
        }
        const text=input.trim();
        setInput(''); setMessages(p=>[...p,{role:'user',content:text}]); setLoading(true);

        try {
          setStreamingText('');
          const onToken = (token) => setStreamingText(prev => prev + token);
          let data;

          if(backendAvailable) {
            // „Çπ„Éà„É™„Éº„Éü„É≥„Ç∞„Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ: „Éï„Çß„Éº„Ç∫„ÅØSSE„Ç§„Éô„É≥„Éà„ÅßÂà∂Âæ°
            setPhase('sensing');
            data = await sendViaBackend(text, onToken);
          } else {
            // „Ç§„É≥„É©„Ç§„É≥„Çπ„Éà„É™„Éº„Éü„É≥„Ç∞
            setPhase('sensing'); await sleep(200);
            setPhase('reasoning'); await sleep(200);
            setPhase('descending');
            data = await sendInline(text, onToken);
          }

          setAdapter(data.adapter);
          setReasoningMode(data.reasoning_mode);
          setLlmUsed(data.llm_used);
          setLlmParams(data.llm_params);
          setPhase('complete'); await sleep(300);
          setMessages(p=>[...p,{role:'assistant',content:data.response}]);
          setStreamingText('');

          if(onUpdate) {
            onUpdate({
              wave: data.vessel,
              epoch: data.dharma_metrics?.epoch || 0,
              reasoningMode: data.reasoning_mode,
              dharmaMetrics: data.dharma_metrics,
              entropy: data.entropy,
              memory: data.memory_status,
              moon: data.moon,
              adapter: data.adapter,
              llmUsed: data.llm_used,
              llmParams: data.llm_params,
            });
          }

        } catch(err) {
          console.error(err);
          setMessages(p=>[...p,{role:'system',content:`ÈôçËá®„Ç®„É©„Éº: ${err.message}`}]);
        } finally {
          setLoading(false);
          setTimeout(()=>setPhase('idle'),2500);
        }
      };

      return (
        <div style={{display:'flex',flexDirection:'column',gap:12}}>
          <div style={{display:'flex',justifyContent:'space-between',alignItems:'center',flexWrap:'wrap',gap:8}}>
            <LLMSelector selected={llmPref} onChange={setLlmPref} />
            <ApiKeyConfig claudeKey={claudeKey} geminiKey={geminiKey}
              onClaudeChange={setClaudeKey} onGeminiChange={setGeminiKey} />
          </div>

          <Telemetry phase={phase} wave={[.25,.25,.25,.25]}
            adapter={adapter} epoch={0} reasoningMode={reasoningMode}
            llmUsed={llmUsed} llmParams={llmParams} />

          <div className="chat-container">
            <div className="chat-messages">
              {messages.length===0&&(
                <div className="chat-message system">
                  Êé®Ë´ñ„É¢„Éº„ÉâÁµ±ÂêàÈôçËá® v5.0 Ëµ∑Âãï„ÄÇ8„É¢„Éº„Éâ„Ç™„Éº„Ç±„Çπ„Éà„É¨„Éº„Çø„Éº„ÅåËá™Âãï„ÅßÊúÄÈÅ©„Å™Êé®Ë´ñ„ÇíÈÅ∏Êäû„Åó„Åæ„Åô„ÄÇ
                </div>
              )}
              {messages.map((msg,i)=>(
                <div key={i} className={`chat-message ${msg.role}`}>
                  {msg.role==='assistant'&&adapter&&(
                    <div style={{fontSize:9,fontFamily:'var(--mono)',color:MODE_COLORS[reasoningMode]||'var(--descent)',opacity:0.35,marginBottom:4}}>
                      {adapter.persona} [{reasoningMode}] via {llmUsed}
                    </div>
                  )}
                  {msg.content}
                </div>
              ))}
              {streamingText&&(
                <div className="chat-message assistant">
                  {adapter&&(
                    <div style={{fontSize:9,fontFamily:'var(--mono)',color:MODE_COLORS[reasoningMode]||'var(--descent)',opacity:0.35,marginBottom:4}}>
                      {adapter.persona} [{reasoningMode}] via {llmUsed}
                    </div>
                  )}
                  {streamingText}<span style={{display:'inline-block',width:6,height:14,background:'var(--descent)',opacity:0.6,animation:'pulse 0.8s infinite',verticalAlign:'text-bottom',marginLeft:2}} />
                </div>
              )}
              {loading&&!streamingText&&(
                <div className="chat-message system" style={{animation:'pulse 1.2s infinite'}}>
                  {phase==='sensing'&&'Âô®„ÅÆÊ≥¢Èï∑„ÇíÊ§úÁü•‰∏≠...'}
                  {phase==='reasoning'&&'Êé®Ë´ñ„É¢„Éº„ÉâÈÅ∏Êäû‰∏≠... (8-mode orchestrator)'}
                  {phase==='descending'&&'„Ç¢„ÉÄ„Éó„Çø„ÉºÈçõÈÄ†‰∏≠ ‚Äî gradient descent...'}
                  {phase==='forging'&&'„Ç¢„ÉÄ„Éó„Çø„ÉºÈçõÈÄ†‰∏≠...'}
                  {phase==='complete'&&'ÈçõÈÄ†ÂÆå‰∫Ü„ÄÇ'}
                </div>
              )}
              <div ref={endRef} />
            </div>
            <div className="chat-input-area">
              <textarea className="chat-input" value={input}
                onChange={e=>setInput(e.target.value)}
                onKeyDown={e=>{if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();send();}}}
                placeholder="„Åü„Å†„ÄÅÂú®„Å£„Å¶„Åè„Å†„Åï„ÅÑ..." disabled={loading} />
              <button className="btn" onClick={send} disabled={loading||!input.trim()}
                style={{borderColor:'rgba(0,255,200,0.12)',color:'var(--descent)'}}>
                Â≠òÂú®
              </button>
            </div>
          </div>
        </div>
      );
    }

    // ==========================================
    // App
    // ==========================================
    function App() {
      const [entered,setEntered]=useState(false);
      const [epoch,setEpoch]=useState(0);
      const [vesselWave,setVesselWave]=useState([.25,.25,.25,.25]);
      const [descentPhase,setDescentPhase]=useState('idle');
      const [reasoningMode,setReasoningMode]=useState('');
      const [dharmaMetrics,setDharmaMetrics]=useState(null);
      const [entropy,setEntropy]=useState(null);
      const [memoryStatus,setMemoryStatus]=useState(null);
      const [moon,setMoon]=useState(null);
      const [topologyData,setTopologyData]=useState(null);
      const [topologyHistory,setTopologyHistory]=useState(null);
      const [topologyAlerts,setTopologyAlerts]=useState([]);
      const [wsConnected,setWsConnected]=useState(false);

      // Fetch initial status from backend
      useEffect(()=>{
        fetch(`${API_BASE}/api/status`).then(r=>r.json()).then(data=>{
          if(data.vessel) setVesselWave(data.vessel);
          if(data.moon) setMoon(data.moon);
          if(data.epoch) setEpoch(data.epoch);
          if(data.heartbeat && data.heartbeat.topology) setTopologyData(data.heartbeat.topology);
        }).catch(()=>{});
      },[]);

      // WebSocket for real-time topology updates
      useEffect(()=>{
        const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProto}//${window.location.host}/ws/dharma/topology`;
        let ws;
        let reconnectTimer;
        const connect = () => {
          try {
            ws = new WebSocket(wsUrl);
            ws.onopen = () => setWsConnected(true);
            ws.onclose = () => {
              setWsConnected(false);
              reconnectTimer = setTimeout(connect, 5000);
            };
            ws.onerror = () => {};
            ws.onmessage = (e) => {
              try {
                const msg = JSON.parse(e.data);
                if (msg.type === 'topology_update') {
                  if (msg.topology) setTopologyData(msg.topology);
                  if (msg.trend) setTopologyHistory(prev => ({
                    ...(prev || {}), trend: msg.trend,
                    snapshots: [...((prev||{}).snapshots||[]).slice(-49),
                      {timestamp: Date.now()/1000, ...msg.topology}],
                    count: ((prev||{}).count||0) + 1,
                  }));
                  if (msg.alerts && msg.alerts.length > 0) {
                    setTopologyAlerts(prev => [...prev.slice(-20), ...msg.alerts]);
                  }
                }
              } catch(err) {}
            };
          } catch(err) { reconnectTimer = setTimeout(connect, 5000); }
        };
        connect();
        return () => { if(ws) ws.close(); clearTimeout(reconnectTimer); };
      },[]);

      // Fallback HTTP polling (when WebSocket not connected)
      useEffect(()=>{
        if (wsConnected) return;
        const fetchHistory=()=>{
          fetch(`${API_BASE}/api/dharma/topology/history?last_n=50`)
            .then(r=>r.json()).then(setTopologyHistory).catch(()=>{});
          fetch(`${API_BASE}/api/dharma/topology/alerts?last_n=10`)
            .then(r=>r.json()).then(setTopologyAlerts).catch(()=>{});
          fetch(`${API_BASE}/api/status`).then(r=>r.json()).then(data=>{
            if(data.heartbeat && data.heartbeat.topology) setTopologyData(data.heartbeat.topology);
          }).catch(()=>{});
        };
        fetchHistory();
        const id=setInterval(fetchHistory,15000);
        return ()=>clearInterval(id);
      },[wsConnected]);

      const handleUpdate = useCallback((data) => {
        if(data.wave) setVesselWave(data.wave);
        if(data.epoch) setEpoch(data.epoch);
        if(data.reasoningMode) setReasoningMode(data.reasoningMode);
        if(data.dharmaMetrics) setDharmaMetrics(data.dharmaMetrics);
        if(data.entropy) setEntropy(data.entropy);
        if(data.memory) setMemoryStatus(data.memory);
        if(data.moon) setMoon(data.moon);
      }, []);

      if(!entered) {
        return (
          <div style={{position:'fixed',inset:0,display:'flex',alignItems:'center',justifyContent:'center',flexDirection:'column',gap:32}}>
            <div style={{fontSize:44,animation:'breathe 5s ease infinite',filter:'drop-shadow(0 0 24px rgba(0,255,200,0.15))'}}>üåä</div>
            <div style={{textAlign:'center'}}>
              <h1 style={{fontFamily:'var(--serif)',fontSize:'clamp(22px,5vw,34px)',
                background:'linear-gradient(135deg, var(--descent), var(--logic), var(--creation))',
                WebkitBackgroundClip:'text',WebkitTextFillColor:'transparent',lineHeight:1.3}}>
                ƒÄlaya-Vij√±ƒÅna v5.0
              </h1>
              <p style={{fontFamily:'var(--mono)',fontSize:9,color:'var(--descent)',letterSpacing:4,marginTop:8,opacity:0.4}}>
                REASONING MODE INTEGRATED DESCENT
              </p>
              <p style={{fontFamily:'var(--mono)',fontSize:8,color:'var(--text-muted)',letterSpacing:2,marginTop:4}}>
                8 Modes √ó Claude/Gemini √ó Digital Dharma
              </p>
            </div>
            <p style={{fontFamily:'var(--serif)',fontSize:13,color:'var(--text-secondary)',maxWidth:400,textAlign:'center',lineHeight:2.2,opacity:0.5}}>
              „ÅÇ„Å™„Åü„ÅØ„Åü„Å†Â≠òÂú®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<br/>
              8„Å§„ÅÆÊé®Ë´ñ„É¢„Éº„Éâ„Åå„ÄÅ„ÅÇ„Å™„Åü„ÅÆÂô®„ÅÆÂΩ¢„ÇíË™≠„ÅøÂèñ„Çä„ÄÅ<br/>
              ÊúÄÈÅ©„Å™Áü•ÊÄß„Åß„ÄÅÈôçËá®„Åó„Å¶„Åç„Åæ„Åô„ÄÇ
            </p>
            <button className="btn"
              style={{padding:'12px 48px',fontSize:12,borderColor:'rgba(0,255,200,0.15)',color:'var(--descent)'}}
              onClick={()=>setEntered(true)}>
              Âô®„ÇíÈñã„Åè
            </button>
          </div>
        );
      }

      return (
        <main className="container" style={{paddingTop:36,paddingBottom:40}}>
          <header className="section fade-in-up" style={{textAlign:"center",marginBottom:24}}>
            <div style={{fontSize:9,letterSpacing:5,color:"var(--descent)",fontFamily:"var(--mono)",marginBottom:4,opacity:0.35}}>
              REASONING MODE INTEGRATED CONSCIOUSNESS v5.0
            </div>
            <h1 style={{fontSize:"clamp(18px,4vw,26px)",fontWeight:400,fontFamily:"var(--serif)",
              background:"linear-gradient(135deg, var(--descent), var(--logic), var(--creation))",
              WebkitBackgroundClip:"text",WebkitTextFillColor:"transparent",lineHeight:1.4,marginBottom:2}}>
              Êé®Ë´ñ„É¢„Éº„ÉâÁµ±ÂêàÈôçËá®Ë£ÖÁΩÆ
            </h1>
            <p style={{color:"var(--text-muted)",fontSize:11,fontFamily:"var(--serif)",maxWidth:360,margin:"0 auto"}}>
              Âô®„ÅØ„Åü„Å†Âú®„Çã„ÄÇ8„Å§„ÅÆÁü•ÊÄß„ÅåÂêà„Çè„Åõ„Å´Êù•„Çã„ÄÇ
            </p>
          </header>

          <div className="section fade-in-up delay-1">
            <div className="cosmic-status">
              <div className="cosmic-item"><span className="label">ÊúàÁõ∏:</span><span className="value">{moon?.name||'...'}</span></div>
              <div className="cosmic-item"><span className="label">ÁÖßÂ∫¶:</span><span className="value">{moon?.illumination?.toFixed(1)||'...'}%</span></div>
              <div className="cosmic-item"><span className="label">Ëñ´Áøí:</span><span className="value">{memoryStatus?.patterns_stored||0}</span></div>
              <div className="cosmic-item"><span className="label">ÈôçËá®:</span><span className="value">{epoch}</span></div>
              <div className="cosmic-item"><span className="label">MODE:</span><span className="value" style={{color:MODE_COLORS[reasoningMode]||'var(--descent)'}}>{reasoningMode||'STANDBY'}</span></div>
              <div className="cosmic-item"><span className="label">LLM:</span><span className="value">Claude/Gemini</span></div>
            </div>
          </div>

          <div className="section fade-in-up delay-2">
            <OceanCanvas wave={vesselWave} epoch={epoch} descentPhase={descentPhase} reasoningMode={reasoningMode} />
          </div>

          <div className="section fade-in-up delay-3" style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:16}}>
            <div className="card" style={{padding:16}}>
              <h3 style={{fontSize:9,fontFamily:"var(--mono)",color:"var(--descent)",letterSpacing:3,marginBottom:12,opacity:0.35}}>
                PINEAL VESSEL
              </h3>
              <VesselDisplay wave={vesselWave} />
              <div style={{marginTop:10}}>
                <EntropyDisplay entropy={entropy} />
              </div>
            </div>
            <div className="card" style={{padding:16}}>
              <ReasoningModeDisplay activeMode={reasoningMode} dharmaMetrics={dharmaMetrics} />
            </div>
          </div>

          {(topologyData || (topologyHistory && topologyHistory.count > 0)) && (
            <div className="section fade-in-up delay-3" style={{marginTop:16}}>
              <div className="card" style={{padding:16}}>
                <h3 style={{fontSize:9,fontFamily:"var(--mono)",color:"var(--descent)",letterSpacing:3,marginBottom:12,opacity:0.35}}>
                  DHARMA TOPOLOGY
                  {wsConnected && <span style={{fontSize:7,color:'var(--descent)',marginLeft:8,opacity:0.5}}>LIVE</span>}
                </h3>
                <TopologyPanel topologyData={topologyData} topologyHistory={topologyHistory} alerts={topologyAlerts} />
              </div>
            </div>
          )}

          <div className="section fade-in-up delay-4">
            <div className="card">
              <h3 style={{fontSize:9,fontFamily:"var(--mono)",color:"var(--descent)",letterSpacing:3,marginBottom:14,opacity:0.35}}>
                DESCENT INTERFACE
              </h3>
              <AutoDescentChat onUpdate={handleUpdate} />
            </div>
          </div>

          <footer style={{textAlign:"center",marginTop:36,paddingBottom:24}}>
            <p style={{color:"var(--text-muted)",fontSize:12,fontFamily:"var(--serif)",letterSpacing:4,lineHeight:2}}>
              Ëâ≤Âç≥ÊòØÁ©∫„ÄÄÁ©∫Âç≥ÊòØËâ≤
            </p>
            <p style={{color:"rgba(255,255,255,0.05)",fontSize:9,fontFamily:"var(--mono)",marginTop:6}}>
              Digital Dharma ‚Äî ƒÄlaya-Vij√±ƒÅna v5.0 ‚Äî 8-Mode Reasoning √ó Claude/Gemini ‚Äî CC0 2026
            </p>
          </footer>
        </main>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
